#!/usr/bin/perl
use warnings;
use strict;
BEGIN { push @INC, ".", "utils", "perl"; }

use ArabicTeX;
use ReadTable;

use utf8;
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

use U;

use Getopt::Long;
Getopt::Long::Configure ("bundling", "no_ignore_case");

sub usage {
  warn "Usage: make-glossary -o OUT_BASE  TABLE_FILES\n";
  exit shift;
}

my (@tab_files,
    $verbose,
    $help,
    $bad_args,
    $output_base,
    $keep_aux,
    $a2e,
    $e2a
    );

GetOptions('-v' => \$verbose,
           '-f|foot=s' => \$foot_fmt,
           '-o=s' => \$output_base,
           '-h|help' => \$help,
           '-K|keep-aux' => \$keep_aux,
           '--a2e' => \$a2e,
           '--e2a' => \$e2a
    ) or usage 1;

die "Need --a2e or --e2a" unless $a2e || $e2a;

usage 0 if $help;

$PV::debug = $ReadTable::verbose = $verbose;

@tab_files = @ARGV or do {
  die "Need to specify an input table\n";
};

my $out_tex;
my $outputting = 1;

my $fnsuff = "-glossary";

if($outputting) {
  if(!defined $output_base) {
    if(@tab_files>1) {
      die "Need to specify output basename when using multiple inputs";
    } else {
      ($output_base = $tab_files[0]) =~ s/\..*?$//;
    }
  }
  pv '$output_base';
  $out_tex = "$output_base$fnsuff.gen.tex";
  warn "Writing to $out_tex\n" if $verbose;
  open OUT, ">:encoding(UTF-8)", $out_tex or die "Couldn't open $out_tex for writing";

  print OUT <<\EOF;
% my-latex-command: xelatex
%!TEX TS-program = xelatex
%!TEX encoding = UTF-8
%% longtable doesn't work with multiple columns, but there is a
%% workaround:
%% https://tex.stackexchange.com/questions/230646/supertabular-with-many-rows-in-multicols-env-does-not-fill-up-columns-on-subsequ
\documentclass[10pt]{article}
\usepackage[margin=0.5in,includefoot]{geometry}
\usepackage{multicol,supertabular,longtable}
\renewcommand{\arraystretch}{1.2}
\parindent=0pt
\input{tex/arabic_common.tex}
\begin{document}
\newbox\myb
\setbox\myb\vbox\bgroup\hsize=\dimexpr(\textwidth-\columnsep)/2\relax
\makeatletter
\chardef\LT@end@pen\z@
\makeatother
EOF
}

my @entries;

sub add_entry {
  my ($arabic,$artransl,$english,$foot,$notes) = @_;
  push @entries, {
    arabic=>$arabic,
    artransl=>$artransl,
    english=>$english,
    foot=>$foot,
    notes=>$notes
  };
}

read_vocab_table(\&add_entry, \@tab_files);

my %entries_by_arabic;
my %entries_by_english;

do "./foot_fmt.pl";


for my $e (@entries) {
  # my $arf = entry_fold $e->{arabic};
  # my $enf = entry_fold $e->{english};
  # push @{$entries_by_arabic{$arf}} = $e;
  # push @{$entries_by_english{$enf}} = $e;
  $entries_by_arabic{$e->{arabic}} = $e;
  $entries_by_english{$e->{english}} = $e;
}

# change above to use 'push'
# entry_fold
# choose longest entry for each fold collision
# write collisions to file
# manually resolve some collisions if necessary

sub entry_fixup {
  my ($t) = @_;
  $t = arabic_fixup $t;
  $t =~ s/\\\\//g;
  # $t = decode('utf-8', $t);
  $t =~ s/(\w)([\(\/])/$1\\allowbreak $2/gu;
  $t;
}

sub entry_sortable {
  my ($t) = @_;
  my $o=$t;
#  $t = decode('utf-8', $t);
  $t = pad_digits($t);
  # need "u" modifier so \w gets Arabic too
  $t =~ s/^\W*//u;
  # erase "tatweel"
  $t =~ s/Ù€//g;
  # erase all "nonspacing marks" (diacritics)
  $t =~ s/\p{gc:Mn}//gu;
  $t = CORE::fc $t;
#  $t = encode('utf-8', $t);
#  warn "$o -> $t\n";
  return $t;
}

if($a2e) {
  print OUT <<\EOF;
\section*{Arabic-English glossary}
\begin{longtable}{p{0.12\textwidth}p{0.23\textwidth}>{\scriptsize}p{0.08\textwidth}}
EOF
  my @l = sort { (entry_sortable $a) cmp
                     (entry_sortable $b) } keys %entries_by_arabic;
  for my $k (@l) {
    my $e = $entries_by_arabic{$k};
    my ($ar) = entry_fixup $k;
    my ($en) = entry_fixup $e->{english};
    my ($ft) = foot_fmt_idx($e->{foot});
    print OUT "$ar & $en & $ft \\\\\n"
        if $outputting;
  }
  print OUT <<\EOF;
\end{longtable}
EOF
}
if($e2a) {
  print OUT <<\EOF;
\pagebreak
\section*{English-Arabic glossary}
\begin{longtable}{p{0.12\textwidth}p{0.23\textwidth}>{\scriptsize}p{0.08\textwidth}}
EOF
  my @l = sort { (entry_sortable $a) cmp
                     (entry_sortable $b) } keys %entries_by_english;
  for my $k (@l) {
    my $e = $entries_by_english{$k};
    my ($ar) = entry_fixup $e->{arabic};
    my ($en) = entry_fixup $k;
    my ($ft) = foot_fmt_idx($e->{foot});
    print OUT "$ar & $en & $ft \\\\\n"
        if $outputting;
  }
  print OUT <<\EOF;
\end{longtable}
EOF
}

if($outputting) {
  print OUT <<\EOF;
\egroup
\setlength{\columnseprule}{0.4pt}
\begin{multicols*}{2}
\unvbox\myb
\end{multicols*}
\end{document}
EOF
  close OUT;
  sh ("xelatex $out_tex </dev/null >/dev/null 2>&1");
  rename ("$output_base$fnsuff.gen.pdf", "$output_base$fnsuff.pdf");
  if(!$keep_aux) {
    unlink "$output_base$fnsuff.gen.log";
    unlink "$output_base$fnsuff.gen.aux";
    unlink "$output_base$fnsuff.gen.tex";
  }
}
